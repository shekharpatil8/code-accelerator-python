# coding: utf-8

"""
    Books API

    An API for managing a collection of books, including listing, creating, and retrieving details.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import unittest
from datetime import datetime
import re
from pydantic import ValidationError, BaseModel
from com.everestek.accelerator.evhub.commons.test_data_generator import TestDataGenerator

from com.everestek.accelerator.evhub.dto.error import Error

class TestError(unittest.TestCase):
    """Error unit test stubs"""


    def setUp(self):
        self.data = TestDataGenerator.generate_sample_data(Error)
        self.instance = Error(**self.data)
    
    def test_instance_creation(self):
        """Test instance creation with valid data"""
        self.assertEqual(self.instance.model_dump(by_alias=True, mode="json"), self.data)
    
    def test_valid_data(self):
        """Test creating an instance with valid manually provided data"""
        valid_data = TestDataGenerator.generate_sample_data(Error)
        instance = Error(**valid_data)
        self.assertEqual(instance.model_dump(by_alias=True, mode="json"), valid_data)

    def test_to_dict_and_from_dict(self):
        """Test conversion between dict and object with datetime handling"""
        obj = Error.from_dict(self.data)
        converted_data = obj.to_dict()

        # Convert datetime fields in original data to ISO format for comparison
        expected_data = self.data.copy()
        for key, value in expected_data.items():
            if isinstance(value, datetime):
                expected_data[key] = value.isoformat()

        self.assertEqual(converted_data, expected_data)
    
    
    def test_to_json_and_from_json(self):
        """Test conversion between JSON and object"""
        # Convert dictionary -> JSON string
        json_str = self.instance.to_json()

        # Convert JSON string -> object
        obj = Error.from_json(json_str)

        # Convert object -> dictionary
        converted_data = obj.to_dict()

        # Convert original data's datetime fields to ISO format if needed
        expected_data = self.data.copy()
        for key, value in expected_data.items():
            if isinstance(value, datetime):
                expected_data[key] = value.isoformat()

        # Assert the converted data matches the original input
        self.assertEqual(converted_data, expected_data)

    
    def test_from_dict_with_none(self):
        """Test from_dict with None input"""
        self.assertIsNone(Error.from_dict(None))
    
    def test_from_dict_with_invalid_type(self):
        """Test from_dict with non-dict input"""
        with self.assertRaises(ValidationError):
            Error.from_dict("invalid")
    
    def test_invalid_data(self):
        """Test validation errors on invalid data"""
        invalid_data = TestDataGenerator.generate_invalid_data(Error)
        with self.assertRaises(ValidationError):
            Error(**invalid_data)
    
    def test_to_str(self):
        """Test string representation"""
        obj = Error.from_dict(self.data)  # Convert dict to object
        str_representation = obj.to_str()  # Convert object to string

        # Convert object to dict (expected)
        expected_dict = obj.to_dict()

        # Convert datetime fields in the expected dictionary to ISO format
        for key, value in expected_dict.items():
            if isinstance(value, datetime):
                expected_dict[key] = value.isoformat()

        # Ensure the string representation contains all key-value pairs
        for key, value in expected_dict.items():
            self.assertIn(str(key), str_representation)

            # If the value is a datetime, convert it to Python's default `datetime.datetime(...)` format for comparison
            if isinstance(value, str) and re.match(r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}", value):
                datetime_value = datetime.fromisoformat(value)
                self.assertTrue(
                    f"datetime.datetime({datetime_value.year}, {datetime_value.month}, {datetime_value.day}, {datetime_value.hour}, {datetime_value.minute}, {datetime_value.second}" in str_representation,
                    f"Expected datetime representation not found in: {str_representation}"
                )
            else:
                self.assertIn(str(value), str_representation)


if __name__ == '__main__':
    unittest.main()
